# Azure DevOps Pipeline - Build Deployment Package
# Equivalente al workflow de GitHub Actions

trigger:
  branches:
    include:
      - main
      - release/*
  paths:
    include:
      - '*/src/**'           # Cambios en source de cualquier form
      - '*/package.json'     # Cambios en package.json de forms
      - 'build-form.js'      # Cambios en script de build compartido

# No trigger on PR
pr: none

# Variables globales
variables:
  nodeVersion: '18.x'
  artifactName: 'deployment-package'

# Pool de agentes
pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: Build
    displayName: 'Build Deployment Package'
    jobs:
      - job: BuildForms
        displayName: 'Build and Package Forms'
        steps:
          # Checkout del cÃ³digo
          - checkout: self
            fetchDepth: 0  # Necesario para git log
            displayName: 'Checkout code'

          # Setup Node.js
          - task: NodeTool@0
            inputs:
              versionSpec: $(nodeVersion)
            displayName: 'Setup Node.js $(nodeVersion)'

          # Instalar dependencias
          - script: |
              npm install
            displayName: 'Install dependencies'

          # Obtener build metadata (commit hash y fecha)
          - task: Bash@3
            name: GetBuildMetadata
            displayName: 'Get build metadata (commit hash and date)'
            inputs:
              targetType: 'inline'
              script: |
                COMMIT_HASH=$(git rev-parse HEAD)
                SHORT_HASH=$(git rev-parse --short HEAD)
                BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

                echo "##vso[task.setvariable variable=commitHash;isOutput=true]$COMMIT_HASH"
                echo "##vso[task.setvariable variable=shortHash;isOutput=true]$SHORT_HASH"
                echo "##vso[task.setvariable variable=buildDate;isOutput=true]$BUILD_DATE"

                echo "ğŸ”– Commit: $SHORT_HASH"
                echo "ğŸ“… Build Date: $BUILD_DATE"

          # Detectar formularios modificados
          - task: Bash@3
            name: DetectChangedForms
            displayName: 'Detect changed forms'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ” Detecting changed forms..."

                # Obtener lista de forms modificados desde el Ãºltimo commit
                CHANGED_FORMS=$(git diff --name-only HEAD~1 HEAD | grep -E '^[^/]+/(src/|package\.json)' | cut -d'/' -f1 | sort -u || true)

                if [ -z "$CHANGED_FORMS" ]; then
                  echo "âš ï¸  No forms changed, building all forms"
                  # Si no hay cambios, buscar todos los forms
                  CHANGED_FORMS=$(find . -type f -name "package.json" -not -path "*/node_modules/*" -not -path "./package.json" | xargs dirname | xargs -n1 basename)
                fi

                # Convertir a array para Azure DevOps
                FORMS_ARRAY=$(echo "$CHANGED_FORMS" | tr '\n' ' ')
                echo "##vso[task.setvariable variable=changedForms;isOutput=true]$FORMS_ARRAY"

                echo "ğŸ“ Forms to build:"
                echo "$CHANGED_FORMS"

          # Calcular versiones independientes por formulario
          - task: Bash@3
            name: CalculateFormVersions
            displayName: 'Calculate per-form versions (independent versioning)'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ”¢ Calculating independent versions for each form..."
                echo ""

                CHANGED_FORMS="$(DetectChangedForms.changedForms)"
                COMMIT_MSG=$(git log -1 --pretty=%B)

                # Detectar tipo de cambio para todas las formas
                if echo "$COMMIT_MSG" | grep -qiE "^(BREAKING CHANGE|major):"; then
                  BUMP_TYPE="major"
                  echo "ğŸ”¼ Bump type detected: MAJOR (breaking changes)"
                elif echo "$COMMIT_MSG" | grep -qiE "^(feat|feature|minor):"; then
                  BUMP_TYPE="minor"
                  echo "ğŸ”¼ Bump type detected: MINOR (new features)"
                else
                  BUMP_TYPE="patch"
                  echo "ğŸ”¼ Bump type detected: PATCH (fixes/chores)"
                fi
                echo ""

                # Procesar cada form individualmente
                for form_name in $CHANGED_FORMS; do
                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  echo "ğŸ“¦ Processing: $form_name"
                  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

                  # 1. Buscar Ãºltimo tag git de este form (source of truth)
                  LAST_TAG=$(git describe --tags --match "${form_name}-v*" --abbrev=0 2>/dev/null || echo "")

                  if [ -n "$LAST_TAG" ]; then
                    LAST_DEPLOYED_VERSION=${LAST_TAG#${form_name}-v}
                    echo "âœ… Last deployed version (git tag): $LAST_DEPLOYED_VERSION"
                  else
                    # Sin tag previo, comenzar desde 1.0.0 (no 0.0.0)
                    LAST_DEPLOYED_VERSION="0.0.0"
                    echo "â„¹ï¸  No previous deployment found, will start from 1.0.0"
                  fi

                  # 2. Leer package.json actual
                  if [ -f "$form_name/package.json" ]; then
                    PACKAGE_VERSION=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
                    echo "ğŸ“„ Current package.json version: $PACKAGE_VERSION"
                  else
                    echo "âŒ ERROR: package.json not found for $form_name"
                    exit 1
                  fi

                  # 3. Validar si coinciden (auto-correction check)
                  if [ "$PACKAGE_VERSION" != "$LAST_DEPLOYED_VERSION" ]; then
                    echo ""
                    echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "âš ï¸  VERSION MISMATCH DETECTED!"
                    echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "âš ï¸  Expected (last deployed): $LAST_DEPLOYED_VERSION"
                    echo "âš ï¸  Found in package.json:    $PACKAGE_VERSION"
                    echo "âš ï¸  "
                    echo "âš ï¸  This means a developer manually changed package.json"
                    echo "âš ï¸  Git tags are the source of truth for versioning"
                    echo "âš ï¸  "
                    echo "ğŸ”§ AUTO-CORRECTING to maintain semantic versioning..."
                    echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                  fi

                  # 4. Calcular nueva versiÃ³n basada en el Ãºltimo tag (SOURCE OF TRUTH)
                  IFS='.' read -r MAJOR MINOR PATCH <<< "$LAST_DEPLOYED_VERSION"

                  # Caso especial: sin tag previo (0.0.0) â†’ primera versiÃ³n debe ser 1.0.0
                  if [ "$LAST_DEPLOYED_VERSION" = "0.0.0" ]; then
                    NEW_VERSION="1.0.0"
                    echo "ğŸ‰ First deployment! Starting at v1.0.0"
                  else
                    # Incremento normal segÃºn bump type
                    if [ "$BUMP_TYPE" = "major" ]; then
                      MAJOR=$((MAJOR + 1))
                      MINOR=0
                      PATCH=0
                    elif [ "$BUMP_TYPE" = "minor" ]; then
                      MINOR=$((MINOR + 1))
                      PATCH=0
                    else
                      PATCH=$((PATCH + 1))
                    fi

                    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
                  fi

                  echo "ğŸ”¼ Version calculation ($BUMP_TYPE bump):"
                  echo "   $LAST_DEPLOYED_VERSION â†’ $NEW_VERSION"
                  echo ""

                  # 5. Actualizar package.json con versiÃ³n correcta
                  echo "ğŸ’¾ Updating $form_name/package.json to version $NEW_VERSION..."
                  jq --arg version "$NEW_VERSION" '.version = $version' "$form_name/package.json" > "$form_name/package.tmp.json"
                  mv "$form_name/package.tmp.json" "$form_name/package.json"

                  echo "âœ… package.json updated successfully"
                  echo ""

                  # 6. Guardar versiÃ³n en output
                  echo "${form_name}_version=$NEW_VERSION" >> /tmp/form_versions.txt

                  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                  echo ""
                done

                echo "âœ… All form versions calculated and package.json files updated"
                echo ""
                echo "ğŸ“‹ Summary of versions:"
                cat /tmp/form_versions.txt

          # Compilar formularios
          - task: Bash@3
            displayName: 'Build changed forms'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ”¨ Building forms..."

                FORMS_TO_BUILD="$(DetectChangedForms.changedForms)"

                for form_name in $FORMS_TO_BUILD; do
                  if [ -d "$form_name" ] && [ -f "$form_name/package.json" ]; then
                    echo "  ğŸ“ Building: $form_name"
                    cd "$form_name"

                    # Verificar que existe el script de build
                    if npm run | grep -q "build"; then
                      npm run build

                      if [ -f "dist/form.js" ]; then
                        echo "  âœ… Built successfully: $form_name ($(wc -c < dist/form.js) bytes)"
                      else
                        echo "  âŒ Build failed: $form_name (no dist/form.js)"
                        exit 1
                      fi
                    else
                      echo "  âš ï¸  No build script found for: $form_name"
                    fi

                    cd ..
                  fi
                done

          # Extraer Release Notes
          - task: Bash@3
            name: ExtractReleaseNotes
            displayName: 'Extract release notes'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“ Extracting release notes..."

                # Obtener release notes del Ãºltimo commit
                COMMIT_MESSAGE=$(git log -1 --pretty=format:"%B")

                # Si el mensaje del commit tiene formato especial (conventional commits), extraerlo
                if echo "$COMMIT_MESSAGE" | grep -qE "^(feat|fix|chore|docs|refactor|perf|test):"; then
                  # Extraer todo despuÃ©s del tÃ­tulo (primera lÃ­nea)
                  RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | tail -n +2 | sed '/^$/d')

                  if [ -z "$RELEASE_NOTES" ]; then
                    # Si no hay cuerpo, usar solo el tÃ­tulo
                    RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | head -n 1)
                  fi
                else
                  # Usar el mensaje del commit completo
                  RELEASE_NOTES="$COMMIT_MESSAGE"
                fi

                # Si estÃ¡ vacÃ­o, usar mensaje por defecto
                if [ -z "$RELEASE_NOTES" ]; then
                  RELEASE_NOTES="Version $(GetVersionInfo.packageVersion) - Build automÃ¡tico desde Azure DevOps"
                fi

                # Guardar en archivo temporal
                echo "$RELEASE_NOTES" > /tmp/release_notes.txt

                echo "âœ… Release notes extracted:"
                echo "$RELEASE_NOTES"

          # Generar manifest.json
          - task: Bash@3
            name: GenerateManifest
            displayName: 'Generate manifest.json'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“‹ Generating manifest.json..."

                # Crear manifest.json dinÃ¡micamente
                cat > manifest.json << EOF
                {
                  "buildDate": "$(GetBuildMetadata.buildDate)",
                  "commitHash": "$(GetBuildMetadata.commitHash)",
                  "commitShortHash": "$(GetBuildMetadata.shortHash)",
                  "repositoryUrl": "$(Build.Repository.Uri)",
                  "forms": [
                EOF

                # Leer release notes del archivo temporal
                RELEASE_NOTES=$(cat /tmp/release_notes.txt)

                # Agregar SOLO los forms compilados al manifest
                FORMS_TO_MANIFEST="$(DetectChangedForms.changedForms)"
                first=true

                for form_name in $FORMS_TO_MANIFEST; do
                  # Verificar que exista el form compilado
                  if [ -d "$form_name" ] && [ -f "$form_name/package.json" ] && [ -f "$form_name/dist/form.js" ]; then
                    version=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
                    description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
                    author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")

                    # ProcessName = FormName con capitalizaciÃ³n (AprobacionGastos)
                    process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')

                    size=$(wc -c < "$form_name/dist/form.js")

                    # Escapar release notes para JSON
                    release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

                    # Agregar coma si no es el primero
                    if [ "$first" = false ]; then
                      echo "," >> manifest.json
                    fi
                    first=false

                    # Agregar form al manifest con releaseNotes y git tag
                    cat >> manifest.json << FORM_EOF
                    {
                      "formName": "$form_name",
                      "processName": "$process_name",
                      "version": "$version",
                      "gitTag": "${form_name}-v${version}",
                      "author": "$author",
                      "description": "$description",
                      "sizeBytes": $size,
                      "path": "forms/$form_name/form.js",
                      "releaseNotes": $release_notes_json
                    }
                FORM_EOF
                  fi
                done

                # Cerrar manifest.json
                cat >> manifest.json << EOF
                  ]
                }
                EOF

                # Pretty print
                jq '.' manifest.json > manifest.tmp && mv manifest.tmp manifest.json

                echo "âœ… Manifest generated:"
                cat manifest.json

                # Contar forms
                form_count=$(jq '.forms | length' manifest.json)
                echo "##vso[task.setvariable variable=formCount;isOutput=true]$form_count"

          # Crear estructura del paquete
          - task: Bash@3
            displayName: 'Create deployment package structure'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“¦ Creating deployment package structure..."

                mkdir -p deployment-package/forms

                # Copiar manifest.json
                cp manifest.json deployment-package/

                # Copiar SOLO los forms que fueron compilados
                FORMS_TO_PACKAGE="$(DetectChangedForms.changedForms)"

                for form_name in $FORMS_TO_PACKAGE; do
                  if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
                    mkdir -p "deployment-package/forms/$form_name"
                    cp "$form_name/dist/form.js" "deployment-package/forms/$form_name/"
                    echo "  âœ… Copied: $form_name"
                  fi
                done

                echo "ğŸ“‚ Package structure:"
                find deployment-package -type f

          # Verificar estructura
          - task: Bash@3
            displayName: 'Verify deployment package'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“‹ Package structure:"
                find deployment-package -type f

                echo ""
                echo "ğŸ“Š Package stats:"
                du -sh deployment-package
                echo "Forms: $(GenerateManifest.formCount)"

          # Crear ZIPs individuales por formulario
          - task: Bash@3
            displayName: 'Create deployment ZIPs (one per form with independent versions)'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“¦ Creating individual deployment ZIPs for each form..."

                FORMS_TO_PACKAGE="$(DetectChangedForms.changedForms)"
                SHORT_HASH="$(GetBuildMetadata.shortHash)"

                for form_name in $FORMS_TO_PACKAGE; do
                  if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
                    echo ""
                    echo "ğŸ“ Creating ZIP for: $form_name"

                    # Leer versiÃ³n de package.json (ya actualizado en step anterior)
                    FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                    echo "  Version: $FORM_VERSION"

                    # Crear estructura temporal para este form
                    mkdir -p "temp-package-$form_name"

                    # Copiar manifest.json
                    cp deployment-package/manifest.json "temp-package-$form_name/"

                    # Copiar solo este form
                    mkdir -p "temp-package-$form_name/forms/$form_name"
                    cp "$form_name/dist/form.js" "temp-package-$form_name/forms/$form_name/"

                    # Nombre del ZIP especÃ­fico para este form CON SU VERSIÃ“N INDIVIDUAL
                    PACKAGE_NAME="${form_name}-deployment-${FORM_VERSION}-${SHORT_HASH}.zip"

                    # Crear ZIP
                    cd "temp-package-$form_name"
                    zip -r "../$(Build.ArtifactStagingDirectory)/$PACKAGE_NAME" .
                    cd ..

                    # Limpiar directorio temporal
                    rm -rf "temp-package-$form_name"

                    echo "  âœ… Created: $PACKAGE_NAME"
                  fi
                done

                echo ""
                echo "ğŸ“Š Deployment ZIPs created:"
                ls -lh "$(Build.ArtifactStagingDirectory)"/*.zip 2>/dev/null || echo "  No ZIPs found"

                echo ""
                echo "ğŸ”— Traceability:"
                echo "  - Each ZIP is named: {form-name}-deployment-{form-version}-{hash}.zip"
                echo "  - ZIP filename includes INDEPENDENT version per form + commit hash"
                echo "  - manifest.json has per-form git tags"

          # Publicar artefactos
          - task: PublishBuildArtifacts@1
            displayName: 'Publish deployment packages'
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: '$(artifactName)'
              publishLocation: 'Container'

          # Commit y push de versiones actualizadas y creaciÃ³n de tags
          - task: Bash@3
            displayName: 'Commit updated versions and create git tags'
            inputs:
              targetType: 'inline'
              script: |
                echo "ğŸ“ Committing updated package.json files and creating git tags..."

                # Configurar git
                git config user.name "Azure Pipelines"
                git config user.email "azuredevops@microsoft.com"

                # Agregar package.json actualizados
                git add */package.json || true

                # Verificar si hay cambios
                if git diff --staged --quiet; then
                  echo "âš ï¸  No package.json changes to commit"
                else
                  # Obtener lista de forms con versiones para el commit message
                  FORMS_WITH_VERSIONS=""
                  CHANGED_FORMS="$(DetectChangedForms.changedForms)"
                  for form_name in $CHANGED_FORMS; do
                    if [ -f "$form_name/package.json" ]; then
                      FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                      FORMS_WITH_VERSIONS="${FORMS_WITH_VERSIONS}\n  - $form_name: v$FORM_VERSION"
                    fi
                  done

                  # Crear commit
                  git commit -m "chore: update versions [skip ci]" \
                             -m "Generated by Azure Pipeline $(Build.BuildNumber)" \
                             -m "Commit: $(GetBuildMetadata.commitHash)" \
                             -m "" \
                             -m "Updated forms:${FORMS_WITH_VERSIONS}" \
                             -m "" \
                             -m "ğŸ¤– Automated commit by Azure DevOps"

                  # Push del commit
                  git push origin HEAD:main

                  echo "âœ… Updated package.json files committed and pushed"
                fi

                # Crear tags por formulario
                echo ""
                echo "ğŸ·ï¸  Creating per-form version tags..."

                CHANGED_FORMS="$(DetectChangedForms.changedForms)"

                for form_name in $CHANGED_FORMS; do
                  if [ -f "$form_name/package.json" ]; then
                    FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                    TAG_NAME="${form_name}-v${FORM_VERSION}"

                    echo ""
                    echo "ğŸ“¦ Form: $form_name"
                    echo "   Version: $FORM_VERSION"
                    echo "   Tag: $TAG_NAME"

                    # Verificar si el tag ya existe
                    if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
                      echo "   âš ï¸  Tag $TAG_NAME already exists, skipping"
                    else
                      # Crear tag anotado
                      git tag -a "$TAG_NAME" \
                              -m "Release $form_name v$FORM_VERSION" \
                              -m "Auto-generated by Azure Pipeline $(Build.BuildNumber)" \
                              -m "Build date: $(GetBuildMetadata.buildDate)" \
                              -m "Commit: $(GetBuildMetadata.commitHash)"

                      # Push del tag
                      git push origin "$TAG_NAME"

                      echo "   âœ… Tag $TAG_NAME created and pushed"
                    fi
                  fi
                done

                echo ""
                echo "âœ… All form-specific tags processed"

          # Resumen del build
          - task: Bash@3
            displayName: 'Build summary'
            inputs:
              targetType: 'inline'
              script: |
                echo "## ğŸ‰ Deployment Package Built Successfully"
                echo ""
                echo "**Build Date**: $(GetBuildMetadata.buildDate)"
                echo "**Commit**: $(GetBuildMetadata.commitHash)"
                echo "**Forms Built**: $(GenerateManifest.formCount)"
                echo ""
                echo "### ğŸ“¦ Forms with Independent Versions"

                # Listar forms con sus versiones y tags
                CHANGED_FORMS="$(DetectChangedForms.changedForms)"
                for form_name in $CHANGED_FORMS; do
                  if [ -f "$form_name/package.json" ]; then
                    FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                    echo "- **$form_name**: v$FORM_VERSION (tag: ${form_name}-v${FORM_VERSION})"
                  fi
                done

                echo ""
                echo "### ğŸ“¥ Download"
                echo "Los paquetes individuales estÃ¡n disponibles en los artefactos del build"
                echo ""
                echo "### ğŸ“¤ Upload Instructions"
                echo "1. Descarga el ZIP especÃ­fico del form desde los artefactos"
                echo "2. Transfiere al servidor offline"
                echo "3. Sube vÃ­a: /admin/upload-forms"
                echo ""
                echo "### â„¹ï¸ Versioning System"
                echo "- Each form has **independent versioning**"
                echo "- Git tags are the **source of truth** (format: {form-name}-v{version})"
                echo "- package.json versions are auto-corrected if manually changed"
